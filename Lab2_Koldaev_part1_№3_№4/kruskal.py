import networkx as nx
import matplotlib.pyplot as plt
import time

# список ребер графа (длина, вершина 1, вершина 2)
R = [(12, 2, 3), (10, 1, 6), (8, 5, 8), (7, 4, 7), (6, 1, 2),
     (5, 6, 7), (5, 5, 7), (4, 4, 5), (2, 7, 8), (1, 4, 6),
     (1, 3, 8), (1, 3, 5), (1, 2, 5), (1, 2, 4), (1, 1, 4)]

# время выполнение алгоритма
start_time = time.time()
for i in range(10000):  # запуск алгоритма несколько раз для получения адекватных значений времени
    Rs = sorted(R, key=lambda x: x[0])  # сортировка по длине ребер
    U = set()   # список соединенных вершин
    D = {}      # словарь списка изолированных групп вершин
    T = []      # список ребер остова

    for r in Rs:
        if r[1] not in U or r[2] not in U:  # проверка для исключения циклов в остове
            if r[1] not in U and r[2] not in U: # если обе вершины не соединены, то
                D[r[1]] = [r[1], r[2]]          # формируем в словаре ключ с номерами вершин
                D[r[2]] = D[r[1]]               # и связываем их с одним и тем же списком вершин
            else:                           # иначе
                if not D.get(r[1]):             # если в словаре нет первой вершины, то
                    D[r[2]].append(r[1])        # добавляем в список первую вершину
                    D[r[1]] = D[r[2]]           # и добавляем ключ с номером первой вершины
                else:
                    D[r[1]].append(r[2])        # иначе, все то же самое делаем со второй вершиной
                    D[r[2]] = D[r[1]]

            T.append(r)             # добавляем ребро в остов
            U.add(r[1])             # добавляем вершины в множество U
            U.add(r[2])

    for r in Rs:    # проходим по ребрам второй раз и объединяем разрозненные группы вершин
        if r[2] not in D[r[1]]:     # если вершины принадлежат разным группам, то объединяем
            T.append(r)             # добавляем ребро в остов
            gr1 = D[r[1]]
            D[r[1]] += D[r[2]]      # объединем списки двух групп вершин
            D[r[2]] += gr1

end_time = time.time()
print(end_time-start_time)
print(T)

graph = nx.Graph()
kilometres = set()
for i in T:
    kilometres.add((i[1], i[2], i[0]))
graph.add_weighted_edges_from(kilometres)
nx.draw_circular(graph, node_color='red', node_size=500, with_labels=True)

plt.show()
